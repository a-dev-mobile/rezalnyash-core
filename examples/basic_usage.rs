use rayon::vec;
use rezalnyas_core::{
    enums::{
        cut_orientation_preference::CutOrientationPreference,
        optimization_priority::OptimizationPriority, status::Status,
    }, log_debug, log_error, log_info, log_warn, logging::{init_logging, LogConfig, LogLevel}, models::{
        calculation_request::CalculationRequest, configuration::Configuration, grouped_tile_dimensions::{get_distinct_grouped_tile_dimensions, GroupedTileDimensions}, panel::structs::Panel, performance_thresholds::PerformanceThresholds, task::structs::Task, tile::tile_conversion::grouped_tile_dimensions_list_to_tile_dimensions_list, tile_dimensions::{count_duplicate_permutations, generate_groups, generate_groups_improved, generate_groups_java_compatible, remove_duplicated_permutations, remove_duplicated_permutations_java_compatible, TileDimensions}
    }, scaled_math::{PrecisionAnalyzer, ScaledConverter, ScaledNumber}, services::arrangement::generate_permutations, CutListOptimizerService, CuttingRequest, Material, OptimizationConfig, OptimizationStrategy
};

const MAX_ALLOWED_DIGITS: u8 = 6;
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut unique_tile_id = 1u8;
    println!("üêõ DEBUG MODE: Single-threaded optimization");
    println!(
        "üíª Available cores: {}",
        std::thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(1)
    );

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    init_logging(LogConfig {
        level: LogLevel::Debug,
    });

    log_info!("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ");

    let panels: Vec<Panel> = vec![
        // –î–µ—Ç–∞–ª—å 1: 150.5x100.25 (2 —à—Ç)
        Panel::new(1, "150.5".to_string(), "100.25".to_string(), 2),
        // –î–µ—Ç–∞–ª—å 2: 80.75x60.5 (3 —à—Ç)
        Panel::new(2, "80.75".to_string(), "60.5".to_string(), 3),
        // –î–µ—Ç–∞–ª—å 3: 120.0x45.75 (1 —à—Ç)
        Panel::new(3, "120.0".to_string(), "45.75".to_string(), 1),
        // –î–µ—Ç–∞–ª—å 4: 95.25x75.5 (2 —à—Ç)
        Panel::new(4, "95.25".to_string(), "75.5".to_string(), 2),
        // –î–µ—Ç–∞–ª—å 5: 65.5x85.25 (1 —à—Ç)
        Panel::new(5, "65.5".to_string(), "85.25".to_string(), 1),
        // –î–µ—Ç–∞–ª—å 6: 110.75x55.0 (2 —à—Ç)
        Panel::new(6, "110.75".to_string(), "55.0".to_string(), 2),
        // –î–µ—Ç–∞–ª—å 7: 40.25x90.5 (3 —à—Ç)
        Panel::new(7, "40.25".to_string(), "90.5".to_string(), 3),
        // –î–µ—Ç–∞–ª—å 8: 130.0x35.75 (1 —à—Ç)
        Panel::new(8, "130.0".to_string(), "35.75".to_string(), 1),
    ];

    // –û–¥–Ω–∞ –∑–∞–≥–æ—Ç–æ–≤–∫–∞ (—Ç–∞–∫–∞—è –∂–µ –∫–∞–∫ –≤ Java)
    let stock_panels: Vec<Panel> = vec![Panel::new(
        1,
        "400.0".to_string(),
        "300.0".to_string(),
        1,
    )];

    let config = Configuration {
        cut_thickness: 0.0,
        use_single_stock_unit: false,
        optimization_factor: 2,
        optimization_priority: vec![
            OptimizationPriority::MostTiles,
            OptimizationPriority::LeastWastedArea,
            OptimizationPriority::LeastNbrCuts,
            OptimizationPriority::LeastNbrMosaics,
            OptimizationPriority::BiggestUnusedTileArea,
            OptimizationPriority::MostHvDiscrepancy,
        ],
        cut_orientation_preference: CutOrientationPreference::Both, // –í—Å–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–µ–∑–æ–≤

        consider_orientation: false, // –£—á–∏—Ç—ã–≤–∞—Ç—å –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é –≤–æ–ª–æ–∫–æ–Ω
        min_trim_dimension: 0.0, //  —ç—Ç–æ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ–ª–µ–∑–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ—Å—Ç–∞—Ç–∫–∞ –≤ –ª—é–±–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏, –≤ —Ç–µ—Ö –∂–µ –µ–¥–∏–Ω–∏—Ü–∞—Ö, —á—Ç–æ –∏ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã (–º–º, —Å–º, –¥—é–π–º—ã –∏ —Ç.–¥.).
        performance_thresholds: PerformanceThresholds {
            max_simultaneous_tasks: 1,   // –ú–∞–∫—Å–∏–º—É–º –ø–æ—Ç–æ–∫–æ–≤
            max_simultaneous_threads: 1, // –ú–∞–∫—Å–∏–º—É–º –ø–æ—Ç–æ–∫–æ–≤ –Ω–∞ –∑–∞–¥–∞—á—É
            thread_check_interval: 100,
        },
    };
    let request = CalculationRequest {
        configuration: config,
        panels,
        stock_panels,
    };

    println!("–°–æ–∑–¥–∞–Ω –∑–∞–ø—Ä–æ—Å:");
    println!("- –î–µ—Ç–∞–ª–µ–π: {}", request.panels.len());
    println!("- –ó–∞–≥–æ—Ç–æ–≤–∫–∞: {}x{}", 
        request.stock_panels[0].width, 
        request.stock_panels[0].height);

    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ç–æ—á–Ω–æ—Å—Ç–∏
    let panels = &request.panels;
    let stock_panels = &request.stock_panels;
    let configuration = &request.configuration;

    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π
    let max_decimal_places_panels = Panel::get_max_decimal_places(panels);
    let max_decimal_places_stock = Panel::get_max_decimal_places(stock_panels);

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ—á–Ω–æ—Å—Ç–∏ –¥–ª—è —Ç–æ–ª—â–∏–Ω—ã —Ä–µ–∑–∞ –∏ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –æ–±—Ä–µ–∑–∫–∏
    let cut_thickness_precision =
        PrecisionAnalyzer::count_decimal_places(&configuration.cut_thickness.to_string());
    let min_trim_precision =
        PrecisionAnalyzer::count_decimal_places(&configuration.min_trim_dimension.to_string());

    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏

    let max_decimal_places = [
        max_decimal_places_panels,
        max_decimal_places_stock,
        cut_thickness_precision,
        min_trim_precision,
    ]
    .iter()
    .max()
    .copied()
    .unwrap_or(0);

    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ü–∏—Ñ—Ä –¥–æ –∑–∞–ø—è—Ç–æ–π
    let max_integer_places_panels = Panel::get_max_integer_places(panels);
    let max_integer_places_stock = Panel::get_max_integer_places(stock_panels);

    let cut_thickness_integer =
        PrecisionAnalyzer::count_integer_places(&configuration.cut_thickness.to_string());
    let min_trim_integer =
        PrecisionAnalyzer::count_integer_places(&configuration.min_trim_dimension.to_string());

    let max_integer_places = [
        max_integer_places_panels,
        max_integer_places_stock,
        cut_thickness_integer,
        min_trim_integer,
    ]
    .iter()
    .max()
    .copied()
    .unwrap_or(0);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ü–∏—Ñ—Ä
    // iMax2 - final_precision
    let final_precision = if max_decimal_places + max_integer_places > MAX_ALLOWED_DIGITS {
        log_warn!(
            "Maximum allowed digits exceeded: maxDecimalPlaces[{}] maxIntegerPlaces[{}] maxAllowedDigits[{}]",
            max_decimal_places, max_integer_places, MAX_ALLOWED_DIGITS
        );
        MAX_ALLOWED_DIGITS.saturating_sub(max_integer_places).max(0)
    } else {
        max_decimal_places
    };

    // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω–≤–µ—Ä—Ç–µ—Ä–∞ —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π —Ç–æ—á–Ω–æ—Å—Ç—å—é
    let converter = ScaledConverter::new(final_precision)?;
    // dPow - scale_factor
    let scale_factor = 10_i64.pow(final_precision as u32);
    // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ø–∏—Å–∫–æ–≤ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    let mut tiles = Vec::new();
    let mut stock_tiles = Vec::new();
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–∞–Ω–µ–ª–µ–π (tiles)
    for panel in panels {
        for _ in 0..panel.count {
            let width_scaled = ScaledNumber::from_str(&panel.width, final_precision)?;
            let height_scaled = ScaledNumber::from_str(&panel.height, final_precision)?;

            let tile = TileDimensions {
             id: unique_tile_id, // –ö–ê–ñ–î–ê–Ø –î–ï–¢–ê–õ–¨ –ü–û–õ–£–ß–ê–ï–¢ –£–ù–ò–ö–ê–õ–¨–ù–´–ô ID
                width: width_scaled.raw_value() as u64,
                height: height_scaled.raw_value() as u64,
                orientation: panel.orientation,
                is_rotated: false,
            };

            tiles.push(tile);
           unique_tile_id += 1; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º ID –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π –¥–µ—Ç–∞–ª–∏
        }
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∫–ª–∞–¥—Å–∫–∏—Ö –ø–∞–Ω–µ–ª–µ–π (stock tiles)
    for stock_panel in stock_panels {
        for _ in 0..stock_panel.count {
            let width_scaled = ScaledNumber::from_str(&stock_panel.width, final_precision)?;
            let height_scaled = ScaledNumber::from_str(&stock_panel.height, final_precision)?;

            let stock_tile = TileDimensions {
       id: unique_tile_id, // –ö–ê–ñ–î–ê–Ø –ó–ê–ì–û–¢–û–í–ö–ê –ü–û–õ–£–ß–ê–ï–¢ –£–ù–ò–ö–ê–õ–¨–ù–´–ô ID
                width: width_scaled.raw_value() as u64,
                height: height_scaled.raw_value() as u64,

                orientation: stock_panel.orientation,
                is_rotated: false,
            };

            stock_tiles.push(stock_tile);
        }
    }
    let mut task = Task {
        id: "test_task".to_string(),
        calculation_request: request.clone(),
        factor: scale_factor,
        solutions: Vec::new(),
        status: Status::Idle,
        percentage_done: 0,
        iterations_completed: 0,
        error_message: None,
        best_solution: None,
        start_time: None,
    };

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≥—Ä—É–ø–ø
    let list_generate_groups = generate_groups_java_compatible(&tiles, &stock_tiles, &task);
//–ø–æ–ª—É—á–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –≥—Ä—É–ø–ø—ã
    let distinct_grouped_tile_dimensions =
        get_distinct_grouped_tile_dimensions(&list_generate_groups, &configuration);
    log_debug!("Task[{}] Calculating permutations...", task.id);

    let mut group_info = String::new();
    for (i, (group, count)) in distinct_grouped_tile_dimensions.iter().enumerate() {
        group_info.push_str(&format!(" group[{}:{}*{}] ", i + 1, group, count));
    }

    log_debug!("Task[{}] Groups: {}", task.id, group_info);
    log_info!("Generated {} groups", list_generate_groups.len());
    log_info!(
        "Distinct groups: {}",
        distinct_grouped_tile_dimensions.len()
    );
 //  –°–æ–∑–¥–∞–Ω–∏–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –∫–ª—é—á–µ–π
    let mut sorted_grouped_tiles: Vec<GroupedTileDimensions> =
        distinct_grouped_tile_dimensions.keys().cloned().collect();

    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –ø–ª–æ—â–∞–¥–∏ –≤ —É–±—ã–≤–∞—é—â–µ–º –ø–æ—Ä—è–¥–∫–µ (–∞–Ω–∞–ª–æ–≥ Java Comparator)
    sorted_grouped_tiles.sort_by(|a, b| {
        // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–æ –ø–ª–æ—â–∞–¥–∏ –≤ —É–±—ã–≤–∞—é—â–µ–º –ø–æ—Ä—è–¥–∫–µ (–∫–∞–∫ –≤ Java: b.area - a.area)
        b.get_area().cmp(&a.get_area())
    });

    log_debug!(
        "Successfully sorted {} distinct tile dimensions by area",
        sorted_grouped_tiles.len()
    );

    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    for (i, grouped_tile) in sorted_grouped_tiles.iter().enumerate().take(5) {
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 5
        log_debug!(
            "Sorted[{}]: {} area={}",
            i,
            grouped_tile,
            grouped_tile.get_area()
        );
    }

    log_info!(
        "Sorted {} distinct grouped tiles by area",
        sorted_grouped_tiles.len()
    );
    /*
     * –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫
     *
     * –ï—Å–ª–∏ –≥—Ä—É–ø–ø –±–æ–ª—å—à–µ 7, —Ç–æ –¥–ª—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫ –±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 7 (—Å–∞–º—ã–µ –±–æ–ª—å—à–∏–µ)
     * –û—Å—Ç–∞–ª—å–Ω—ã–µ –≥—Ä—É–ø–ø—ã –¥–æ–±–∞–≤–∏–º –≤ –∫–æ–Ω–µ—Ü –∫–∞–∂–¥–æ–π –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞
     * –≠—Ç–æ —Å–æ–∫—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ —Å —Ñ–∞–∫—Ç–æ—Ä–∏–∞–ª–∞ –¥–æ —Ä–∞–∑—É–º–Ω–æ–≥–æ —á–∏—Å–ª–∞
     */
    let (permutation_tiles, remaining_tiles) = if sorted_grouped_tiles.len() > 7 {
        let permutation_tiles = sorted_grouped_tiles[0..7].to_vec();
        let remaining_tiles = sorted_grouped_tiles[7..].to_vec();

        log_debug!(
            "Task[{}] Optimization: Using first 7 groups for permutations, {} groups will be appended",
            task.id,
            remaining_tiles.len()
        );

        (permutation_tiles, remaining_tiles)
    } else {
        log_debug!(
            "Task[{}] Using all {} groups for permutations",
            task.id,
            sorted_grouped_tiles.len()
        );

        (sorted_grouped_tiles, Vec::new())
    };

    log_info!(
        "Permutation groups: {}, Remaining groups: {}",
        permutation_tiles.len(),
        remaining_tiles.len()
    );

    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø –¥–ª—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫
    for (i, tile) in permutation_tiles.iter().enumerate() {
        log_debug!("Permutation[{}]: {} area={}", i, tile, tile.get_area());
    }

    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –≥—Ä—É–ø–ø
    for (i, tile) in remaining_tiles.iter().enumerate() {
        log_debug!("Remaining[{}]: {} area={}", i, tile, tile.get_area());
    }



     /*
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫
     * 
     * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–µ—Ä–≤—ã—Ö 7 –≥—Ä—É–ø–ø
     * –ö –∫–∞–∂–¥–æ–π –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–µ –¥–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –≥—Ä—É–ø–ø—ã –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
     */
    
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Å–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ –¥–ª—è –≥—Ä—É–ø–ø permutation_tiles
    let mut list_generate_permutations = generate_permutations(permutation_tiles);
    
    log_debug!(
        "Task[{}] Generated {} permutations from {} groups",
        task.id,
        list_generate_permutations.len(),
        list_generate_permutations.first().map_or(0, |p| p.len())
    );
    
    // –ö –∫–∞–∂–¥–æ–π –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–µ –¥–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –≥—Ä—É–ø–ø—ã –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
    for permutation in &mut list_generate_permutations {
        permutation.extend_from_slice(&remaining_tiles);
    }
    
    log_debug!(
        "Task[{}] Final permutations: {} permutations with {} total groups each",
        task.id,
        list_generate_permutations.len(),
        list_generate_permutations.first().map_or(0, |p| p.len())
    );
    
    log_info!(
        "Generated {} total permutations with {} groups each",
        list_generate_permutations.len(),
        list_generate_permutations.first().map_or(0, |p| p.len())
    );
    
    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–≤—ã—Ö –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    for (i, permutation) in list_generate_permutations.iter().take(3).enumerate() {
        let perm_info: String = permutation
            .iter()
            .enumerate()
            .map(|(j, group)| format!("{}[area={}]", j, group.get_area()))
            .collect::<Vec<_>>()
            .join(" ");
        
        log_debug!("Permutation[{}]: {}", i, perm_info);
    }
    
    if list_generate_permutations.len() > 3 {
        log_debug!("... and {} more permutations", list_generate_permutations.len() - 3);
    }



    /*
     * –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫ –≤ —Å–ø–∏—Å–∫–∏ –ø–∞–Ω–µ–ª–µ–π
     * 
     * –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–∞–∂–¥—É—é –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫—É –≥—Ä—É–ø–ø –æ–±—Ä–∞—Ç–Ω–æ –≤ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø–∞–Ω–µ–ª–µ–π
     * –¢–µ–ø–µ—Ä—å sorted_tile_lists —Å–æ–¥–µ—Ä–∂–∏—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ –ø–æ—Ä—è–¥–∫–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –ø–∞–Ω–µ–ª–µ–π
     */
    
    log_debug!("Task[{}] Sorting tiles according to permutations...", task.id);
    

    let mut sorted_tile_lists: Vec<Vec<TileDimensions>> = Vec::new();
    
    for permutation in &list_generate_permutations {
        let sorted_tiles = grouped_tile_dimensions_list_to_tile_dimensions_list(
            permutation,
            &list_generate_groups
        );
        sorted_tile_lists.push(sorted_tiles);
    }
    
    log_debug!(
        "Task[{}] Created {} sorted tile lists from permutations",
        task.id,
        sorted_tile_lists.len()
    );
    
    log_info!(
        "Created {} sorted tile arrangements from permutations",
        sorted_tile_lists.len()
    );
    
    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–≤—ã—Ö –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–ø–∏—Å–∫–æ–≤ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    for (i, sorted_list) in sorted_tile_lists.iter().take(2).enumerate() {
        let tiles_info: String = sorted_list
            .iter()
            .take(5) // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 5 –ø–ª–∏—Ç–æ–∫
            .map(|tile| format!("{}[{}x{}]", tile.id, tile.width, tile.height))
            .collect::<Vec<_>>()
            .join(" ");
        
        log_debug!(
            "SortedList[{}] ({} tiles): {} {}",
            i,
            sorted_list.len(),
            tiles_info,
            if sorted_list.len() > 5 { "..." } else { "" }
        );
    }
    
    if sorted_tile_lists.len() > 2 {
        log_debug!("... and {} more sorted tile lists", sorted_tile_lists.len() - 2);
    }


    /*
     * –£–¥–∞–ª–µ–Ω–∏–µ –¥—É–±–ª–∏—Ä—É—é—â–∏—Ö –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫
     * 
     * –£–¥–∞–ª—è–µ–º –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–≤–æ–¥—è—Ç –∫ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º
     * –≠—Ç–æ —ç–∫–æ–Ω–æ–º–∏—Ç –≤—Ä–µ–º—è –≤—ã—á–∏—Å–ª–µ–Ω–∏–π
     */
    
    log_debug!("Task[{}] Removing duplicated permutations...", task.id);
    

    // –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥—Å—á–∏—Ç–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    let (total_before, unique_before, duplicates_before) = count_duplicate_permutations(&sorted_tile_lists);
    
    log_debug!(
        "Task[{}] Before deduplication: {} total permutations, {} unique, {} duplicates",
        task.id,
        total_before,
        unique_before,
        duplicates_before
    );
    
    // –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏
    let removed_count = remove_duplicated_permutations_java_compatible(&mut sorted_tile_lists);
    
    log_debug!(
        "Task[{}] After deduplication: {} permutations remaining ({} removed)",
        task.id,
        sorted_tile_lists.len(),
        removed_count
    );
    
    log_info!(
        "Removed {} duplicate permutations, {} unique arrangements remaining",
        removed_count,
        sorted_tile_lists.len()
    );
    
    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏–∏
    if total_before > 0 {
        let efficiency_percent = (removed_count as f64 / total_before as f64) * 100.0;
        log_debug!(
            "Task[{}] Deduplication efficiency: {:.1}% duplicates removed",
            task.id,
            efficiency_percent
        );
        
        if efficiency_percent > 10.0 {
            log_debug!("Task[{}] High deduplication efficiency - significant optimization achieved", task.id);
        }
    }

    log_info!("\n=== –ê–ª–≥–æ—Ä–∏—Ç–º –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ ===");
    log_info!("–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {} –¥–µ—Ç–∞–ª–µ–π", tiles.len());
    log_info!("–°–æ–∑–¥–∞–Ω–æ {} –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è", sorted_tile_lists.len());

    Ok(())
}
